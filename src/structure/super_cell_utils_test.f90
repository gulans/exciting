module super_cell_utils_test
   use precision, only: dp
   use modmpi, only: mpiinfo
   use unit_test_framework, only: unit_test_type
   use math_utils, only: all_close
   use super_cell_utils, only: get_translation_vectors, &
                              supercell_atomic_positions, &
                              TranslationIntegers_type, &
                              extend_rmt_natoms
                              
   implicit none
   private
   public :: super_cell_utils_test_driver

contains

   !> Run tests for the super_cell_utils module
   subroutine super_cell_utils_test_driver(mpiglobal, kill_on_failure)
      !> mpi environment
      type(mpiinfo), intent(in) :: mpiglobal
      !> Kill the program upon failure of an assertion
      logical, intent(in), optional :: kill_on_failure

      !> Test report object
      type(unit_test_type) :: test_report
      !> Number of assertions
      integer, parameter :: n_assertions = 15

      call test_report%init(n_assertions, mpiglobal)

      !call functions that test
      call test_get_translation(test_report)
      call test_supercell_atomic_positions(test_report)
      call check_integers_valid(test_report)
      call test_extend_rmt_natoms(test_report)

      if (present(kill_on_failure)) then
         call test_report%report('super_cell_utils', kill_on_failure)
      else
         call test_report%report('super_cell_utils')
      end if
   end subroutine super_cell_utils_test_driver

   subroutine test_get_translation(test_report)
      !> Our test object
      type(unit_test_type), intent(inout) :: test_report

      !> Test input
      !> Lattice vectors
      real(dp) :: lattice_vect(3, 3) = reshape([1.0_dp, 0.0_dp, 1.0_dp, &
                                                0.0_dp, 1.0_dp, 1.0_dp, &
                                                1.0_dp, 1.0_dp, 0.0_dp], &
                                               [3, 3])
      !> Translation integers 
      type(TranslationIntegers_type) :: n0, n1, n2, n3
      !> Translation vectors
      real(dp), allocatable :: translation(:, :)
      !> Middle cell ith element of array
      integer :: i_middle_cell
      !> Origin of supercell
      real(dp) :: origin(3)
      !> References
      real(dp) :: ref0(3,1 ), ref2(3, 2), ref3(3, 4)

      n1 = TranslationIntegers_type([-1, 1], [-1, 1], [-1, 1])

      call test_report%assert(size(get_translation_vectors(lattice_vect, n1), 1) == 3, &
                              'Tests translation size. Expected result: Dimension one of &
                              translation matrix has a size of 3.')
      
      call test_report%assert(size(get_translation_vectors(lattice_vect, n1), 2) == 27, &
                              'Tests translation size. Expected result: Dimension two of &
                              translation matrix has a size of 27.')
      

      n0 = TranslationIntegers_type([0, 0], [0, 0], [0, 0])
      ref0 = reshape([0._dp, 0._dp, 0._dp], [3,1])

      call test_report%assert(all_close(get_translation_vectors(lattice_vect, n0), ref0), &
                              'Tests translation. Expected result: All cells after translation are zero.')
                        
      translation = get_translation_vectors(lattice_vect, n1)
      i_middle_cell = int(0.5*size(translation, 2)) + 1
      origin = [0.0_dp, 0.0_dp, 0.0_dp]

      call test_report%assert(all_close(translation(:, i_middle_cell), origin), &
                              'Tests translation. Expected result: Middle cell of translation is zero: [0, 0, 0].')


      n2 = TranslationIntegers_type([2, 2], [-1, 0], [1, 1])
      ref2 = reshape([3.0_dp, 0.0_dp, 1.0_dp, &
                      3.0_dp, 1.0_dp, 2.0_dp], [3, 2])

      call test_report%assert(size(get_translation_vectors(lattice_vect, n2), 1) == 3, &
                              'Tests translation size. Expected result: Dimension one of &
                              translation matrix has a size of 3.')
      
      call test_report%assert(size(get_translation_vectors(lattice_vect, n2), 2) == 2, &
                              'Tests translation size. Expected result: two translations.')
      
      call test_report%assert(all_close(get_translation_vectors(lattice_vect, n2), ref2), &
                              'Tests the output of the translation vectors. Expected result: &
                              3x2 shaped output, containing the translation vectors columnwise. &
                              Vectors are generated by multiplying the lattice vectors with each &
                              combination of the n2 integers.')

      n3 = TranslationIntegers_type([0, 0], [-1, 0], [1, 2])
      ref3 = reshape([1.0_dp, 0.0_dp, -1.0_dp, &
                      2.0_dp, 1.0_dp, -1.0_dp, &
                      1.0_dp, 1.0_dp, 0.0_dp, &
                      2.0_dp, 2.0_dp, 0.0_dp], [3, 4])

      call test_report%assert(size(get_translation_vectors(lattice_vect, n3), 1) == 3, &
                              'Tests translation size. Expected result: Dimension one of &
                              translation matrix has a size of 3.')
                              
      call test_report%assert(size(get_translation_vectors(lattice_vect, n3), 2) == 4, &
                              'Tests translation size. Expected result: four translations.')

      call test_report%assert(all_close(get_translation_vectors(lattice_vect, n3), ref3), &
                              'Tests the output of the translation vectors. Expected result: &
                              3x4 shaped output, containing the translation vectors columnwise. &
                              Vectors are generated by multiplying the lattice vectors with each &
                              combination of the n3 integers.')
    
   end subroutine test_get_translation

   subroutine check_integers_valid(test_report)
      !> Our test object
      type(unit_test_type), intent(inout) :: test_report

      !> Test input
      !> Invalid translation integers
      type(TranslationIntegers_type) :: n_integers_invalid = TranslationIntegers_type([1, 5], [1, -2], [1, 5])
      !> Valid translation integers
      type(TranslationIntegers_type) :: n_integers_valid = TranslationIntegers_type([-1, 1], [-1, 1], [-1, 1])
      
      call test_report%assert(.not. n_integers_invalid%integers_valid(), 'Test that negative integer ranges are &
                              identified as not valid input. The integers: [1, 5], [1, -2], [1, 5] are not valid &
                              arguments.')
      
      call test_report%assert(n_integers_valid%integers_valid(), 'Tests translation integers. &
                              The integers: [-1, 1], [-1, 1], [-1, 1] are valid arguments.')

   end subroutine check_integers_valid

   subroutine test_supercell_atomic_positions(test_report)
      !> Our test object
      type(unit_test_type), intent(inout) :: test_report

      !> Test input
      !> Number of atoms per species
      integer :: natoms(2) = [1, 1]
      !> Translation
      real(dp), parameter :: translation(3, 1) = reshape([-1.0_dp, 2.0_dp, 1.0_dp], &
                                                         [3, 1])
      !> Atomic positions
      real(dp) :: atomic_postion(3, 1, 2) = reshape([0.0_dp, 0.0_dp, 0.0_dp, &
                                                     0.5_dp, 0.5_dp, 0.5_dp], [3, 1, 2])
      !> Reference
      real(dp) :: ref(3, 2) = reshape([-1.0_dp, 2.0_dp, 1.0_dp, &
                                       -0.5_dp, 2.5_dp, 1.5_dp], [3, 2])

      call test_report%assert(all_close(supercell_atomic_positions(translation, atomic_postion, natoms), &
                                        ref), 'Tests new positions after translation. Expected: [[-1, 2, 1], [-0.5, 2.5, 1.5]]')

   end subroutine test_supercell_atomic_positions

   subroutine test_extend_rmt_natoms(test_report)
      !> Our test object
      type(unit_test_type), intent(inout) :: test_report

      !> Rmt values
      real(dp) :: rmt(3) = [0.3_dp, 4.5_dp, 6.7_dp]
      !> Number of atoms per species
      integer :: natoms(3) = [1, 3, 2]

      call test_report%assert(size(extend_rmt_natoms(natoms, rmt)) == sum(natoms), &
                              'Tests size of extended rmt vector. Expected size &
                              is number of atoms in unit cell (sum of the natoms vector).')

      call test_report%assert(all_close(extend_rmt_natoms(natoms, rmt), [0.3_dp, 4.5_dp, 4.5_dp, 4.5_dp, 6.7_dp, 6.7_dp]), &
                              'Tests result of extended rmt vector.')

   end subroutine test_extend_rmt_natoms

end module super_cell_utils_test
